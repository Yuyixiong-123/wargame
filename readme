项目进度日志
; 小的进度，当天进度的记录
; ! 重要进度，里程碑，方向转变点
; ? 发现的问题
文本：解释性和讨论

###############################################################################
##                             2022年12月20日                                  ##
###############################################################################
; 完成PSO算法
PSO算法中，如果MA，MB矩阵的数值比较大，如235这种，就需要惯性项比较大才能够迅速收敛，不然马上就会陷入局部最优。在解决论文《A predator-prey particle swarm optimization approach to multiple UCAV air combat modeled by dynamic game theory》中提出的Table2时非常明显，可以看出惯性项从大到小的作用。

--2022年12月20日20:35:41
PSO算法都是平均分概率了，是个局部最优难以跳出，需要随着输入参数做调参，现在明显鲁棒性不强，碰对了才能得到结果——有时候容易陷入局部最优。
或者使用论文中提出的“捕食者”优化，可能可以缓解陷入局部最优。

--2022年12月20日21:06:09
如何跳出局部最优解，是一个很重要的研究问题……难怪文章中要用改进的PSO算法; 
使用更大的人口基数：p_num 比 迭代次数更有用——优质的初始解。如果能够收敛到最优解，那么4,5次就收敛了。
; 今天解决了PSO算法求解纳什均衡的问题

###############################################################################
##                             2022年12月21日                                  ##
###############################################################################
; 大维度AB矩阵测试
输入的矩阵A,B还需放缩到一定数量级范围，如-1~2，才能够使得参数处于最优水平，才能保证截断参数和停滞参数是正确的数量级。
测试1e4的计算需要8秒1步。
; ? 测试1e5出现内存占用过大问题，32G内存直接满了，还没有计算出第一步。
实际上，就单说每个单位的移动，就是9个变量，己方5个单位的移动就已经是9^5差不多1e5了，这个PSO算法肯定还是要优化的。

###############################################################################
##                             2022年12月22日                                  ##
###############################################################################
; ! 在构建这个模型的时候，时刻要考虑实现的效率高不高，因为稍微慢一点，在10^6的情况下就是十多分钟……E.g. 数值索引

###############################################################################
##                             2023年1月6日                                  ##
###############################################################################
; 写了最简单的遍历Action-Reaction Search Algorithm.算法
但是难以找到纯策略最优解，很可能是无解的，让我们尝试找一下stackelberg equilibrium
--使用断点测试发现，程序会稳定在一定的内存消耗
--使用float16这个最小的浮点型确实可以减少一部分的内存消耗
--应该是一开始生成random数组消耗了大量内存，后面的计算可能还好

; 使用stackelberg_search_Af方法
可以求解出任意的双矩阵博弈，这样的解是一定存在的。
现在计算时间和内存，都会随着维度的增加，指数扩大，维度从1-2-3-4的过程，计算内存和时间在不断翻倍，因为这个维度本身就是要翻倍的矩阵计算1×1，2×2=4，3×3=9，4×4=16，确实就是在不断翻倍。


; ! 证明了stackelberg equilibrium也是可以分块计算的。

###############################################################################
##                             2023年1月8日                                  ##
###############################################################################
【内存溢出问题】python，一个大的矩阵，确实是占用了3083mb的内存，跟计算出来的内存占用情况差不多，考虑到其他应用也会占到10G左右的内存，加上至少要保存两个支付矩阵，那么如此则32G电脑能够处理的矩阵维度不能很大……最多也就是4e4，不能达到5e4——只能考虑降维，甚至不能出现5e4大小的矩阵，emmm，这对于遍历的方法来说，还是挺不友好的。第一次感受到溢出的恐怖。

我很奇怪，我觉得这个矩阵，他只要产生，就需要这么大的内存。他们都是几百个G的内存条嘛？超算做的是吧。
能够做降维测试的，维度才200×200，太少了，这个维度太低了呀，对于博弈战场来说……
; !基本只能考虑降维来做了，必须去除不合理的状态。逼我们进行预评估和预处理——1e6的矩阵，就不应该被创造出来，只能够先筛选，再构造，然后再进行纳什均衡求解。
这就已经跟智能博弈中，遍历全部可能性的想法相悖了。

###############################################################################
##                             2023年1月9日                                  ##
###############################################################################
考虑一部分智能体是基于规则运动的，减少变量

###############################################################################
##                             2023年1月10日                                  ##
###############################################################################
构建伪代码，确定两个类及其主要参数，函数，明确函数方法的输入输出。

###############################################################################
##                             2023年1月13日                                  ##
###############################################################################
昨天做了一下get_Ur_Ub伪代码的思考，最后还是考虑分区来算，让每一个矩阵的大小都小于2e4^2

###############################################################################
##                             2023年1月14日                                  ##
###############################################################################
需要解决更新状态函数，模拟更新和真实更新之间的区别，估计得是两个函数，看看如何不那么冗余。

; 先做初始化，包括单位的生成，战场参数，给定控制参数格式，写完作战过程的更新

###############################################################################
##                             2023年1月15日                                  ##
###############################################################################
写代码评估eval_cr_cb，然后开始研究遍历的生成，包括get_cb_cr_1stepGT，__get_cr_list，__get_ma_seq函数，对一些数据结构和函数功能做了思考。
考虑直接对全部的序列进行2e4的分割，不用麻烦的专门提取某一类了。